@using System;
@using Helium24.Models;

@{
    String projectName = "Simulator";
    Layout = "Layouts/RootLayout.cshtml";

    Tag[] tags = new Tag[] { Tag.Software, Tag.Simulation };
    ProjectHeader header = new ProjectHeader(projectName, "April 2015", tags);
}

@section Title {@projectName}

<div class="card">
    @Html.Partial("Common/CardHeader.cshtml", header)
    <div class="card-body">
        @Html.Partial("Common/ParagraphStart.cshtml")
            The terribly-named <b>@projectName</b> project was started to investigate a number of technologies.
            Primarily, I wanted to determine the difference between modern OpenGL and modern DirectX, so I wrote this application as a C++ DirectX Windows Modern Application.
            Secondarily, I had previously programmed an electromagnetic simulator that did not take into account the speed of light, 
            so I wanted to attempt creating a more realistic small-scale electromagnetic simulation.
            Finally, I was interested in seeing how creating a full-screen Windows Modern Application would be different than a desktop OpenGL / DirectX application.
        @Html.Partial("Common/ParagraphEnd.cshtml")
    </div>
</div>

<!-- TODO: Make all the styles more muted, add hover-over for links -->
<div id="body">
    
    
    </p>
    <h3>Mathematics</h3>
    <p>
        The mathematics for <b>@projectName</b> were driven from the design requirements that I would not be simulating quantum mechanical effects, and that I'd only
        be dealing with point particles. With my previous simulator, I'd used <i>Lorentz's Force Law</i>, in combination with <i>Newton's Second Law</i> for 
        particle motion, and (approximations) of the electric and magnetic fields based upon the particle positions and velocities.
    </p>
    <div class="content-wrapper">
        <article class="equationSubBox">
            $$\vec{F}=q(\vec{E} + \vec{v}\times\vec{B})$$
        </article>
        <aside class="subbox">
            <b>Lorentz's Force Law</b>, for a point charge in an electric and magnetic field.
        </aside>
    </div>
    <br />
    <div class="content-wrapper">
        <article class="equationSubBox">
            $$\vec{F}=m\vec{a}$$
        </article>
        <aside class="subbox">
            <b>Newton's Second Law</b>. The law is <i>simple</i>, but you have to be careful to use a reasonably-accurate integration method (or tiny timesteps).
        </aside>
    </div>
    <div class="content-wrapper">
        <article class="equationSubBox">
            $$\vec{E(r)}=\frac{1}{4\pi\epsilon_0}\sum\limits_{i}\frac{q_i}{R^2}\hat{R}$$
        </article>
        <aside class="subbox">
            <b>Electric Field</b> at a point \(r\) given \(\vec{R}\) the vector from the point charge to your point \(r\), summed over all particles.
        </aside>
    </div>
    <div class="content-wrapper">
        <article class="equationSubBox">
            $$\vec{B(r)}=\frac{\mu_0}{4\pi}\sum\limits_{i}\frac{q_i\vec{v_i}\times\hat{R_i}}{R_i^2}$$
        </article>
        <aside class="subbox">
            <b>Magnetic Field</b> at a point \(r\) given \(\vec{R_i}\) the vector from the point charges to your point \(r\), summed over all particles.
        </aside>
    </div>
    <p>
        However, the electric and magnetic field approximations above don't take into account the time for a perturbation (such as particle motion) to be visible to
        other particles, given the speed of light and the travel time for the electromagnetic wave. These equations are only correct for non-relativistic particles -- or 
        when we're not interested in realtivistic effects (such as radio waves).
    </p>
    <p>
        For this simulation, I used the moving point charge fields calculation from my E&M course, and stored the history of each particle's motion so that time effects could be properly considered.
    </p>
    <div class="content-wrapper">
        <article class="equationSubBox">
            $$\vec{E(r,t)}=\frac{1}{4\pi\epsilon_0}\sum\limits_{i}\frac{q_iR_i}{(\vec{R_i}\cdot\vec{u_i})^3}((c^2-v_i^2)\vec{u_i}+\vec{R_i}\times(\vec{u_i}\times\vec{a_i}))$$
        </article>
        <aside class="subbox">
            <b>Electric Field</b> at a point \(r\) given \(\vec{R_i}\) the vector from the point charges to your point \(r\) <i>accounting for when the particle was given the light delay</i>, summed over all particles.
        </aside>
    </div>
    <div class="content-wrapper">
        <article class="equationSubBox">
            $$\vec{B(r,t)}=\frac{1}{c}\hat{R}\times\vec{E(r,t)})$$
        </article>
        <aside class="subbox">
            <b>Magnetic Field</b> at a point \(r\) given \(\vec{R_i}\) the vector from the point charges to your point \(r\), summed over all particles. Note that in both cases, \(\vec{u}=c\hat{R}-\vec{v}\)
        </aside>
    </div>
    <p>
        Also, for the physicists out there I didn't add the <i>Abraham-Lorentz</i> force to each particle, because -- as expected -- the particle spontaneously accelerates when done so.
    </p>
    <h3>Software</h3>
    <p>

    </p>
    <br />
    <div class="content-wrapper">
        <article>
            <img class="imgScaler" src="~/Content/Projects/Simulator.png" width="650" />
        </article>
        <minimalProjectAside>
            <b>@projectName</b>: This screenshot shows several technical aspects of the 
            simulation: 
            <ul>
                <li>Geometry-shader generated arrows</li>
                <li>Combining Direct2D and Direct3D to draw info text.</li>
                <li>Interactivity (keyboard, not shown)</li>
                <li>Fullscreen Windows Modern Apps</li>
            </ul>
        </minimalProjectAside>
    </div>
    <p>
        This screenshot also shows the electromagnetic waves from two counter-rotating charged particles. Note that this
        does <i>not</i> show subatomic particles counter-rotating -- such as an electron and a positron<a href="http://en.wikipedia.org/wiki/Electron%E2%80%93positron_annihilation"><sup>+</sup></a> -- because at that
        scale, quantum mechanical effects appear.
    </p>
    <p>
        Surprisingly, I found programming in modern DirectX to be extreemely similar to programming in modern OpenGL. In both cases, you load up the shaders, setup the data format for the shaders, 
        load the vertex buffer with the triangles, and render the result in batch. Even the shading languages (HLSL/GLSL) are very much C-like, with minor differences. Overall, I believe that if you
        know how to do vertex-array-based OpenGL or DirectX programming, you'll be able to transition into using the other language very, very quickly.
    </p>
</div>

@section Scripts{
}